//iam using a 1ns/1ns compiler

module four_bit_adder (
    input [3:0] a,
    input [3:0] b,
    input cin,
    output [3:0] sum,
    output cout
);
  wire [3:0] c;

  genvar i;
  generate
    for (i = 0; i < 4; i = i + 1) begin : adder_loop
      full_adder fa (
        .a(a[i]),
        .b(b[i]),
        .cin(i == 0 ? cin : c[i-1]),// if i=0 its cin, else its the wire c[i-1]
        .sum(sum[i]),
        .cout(c[i])
      );
    end
  endgenerate

  assign cout = c[3];// last c, which is cout
  
endmodule


module full_adder (
    input a,
    input b,
    input cin,
    output sum,
    output cout
);
  wire w1, w2, w3;
  
  // will start instantaniously
  xor #9ns xor1 (w1,a,b);
  and #7ns and1 (w2,a,b);
  
  //will start after xor1 finishes, after 9ns (when w1 changes)
  and #7ns and2 (w3,w1,cin);//16ns
  xor #9ns xor2 (sum,w1,cin);//18ns

  //will start after and1,and2 output, since and1 ends 7ns after the beginning.
  //it will also wait for and2 output, to begin which happens 16ns after beginning.
  or #7 or1 (cout,w2,w3);//23ns

endmodule
