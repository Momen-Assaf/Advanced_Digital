module multiplier_fa #(parameter n = 3) (//MAX DELAY IS(n*92)
//   MAX FREQUENCY IS 1/(n*92) NOTE:THESE CALCULATIONS ARE IN ns
    input [3:0] x,
    input [n:0] y,
    output [n+3:0] res
);
  wire [n+3:0] partial_products [n:0]; // Partial products
  wire [n+3:0] sums [n:0];             // Intermediate sums

  genvar i, j;

  // Generate partial products
  generate
    for (i = 0; i <= n; i = i + 1) begin : partial_product_gen
      for (j = 0; j < 4; j = j + 1) begin : bit_mult
        assign partial_products[i][j + i] = x[j] & y[i];
      end
      // Fill the rest with zeros
      for (j = 0; j < i; j = j + 1) begin : zero_fill_before
        assign partial_products[i][j] = 1'b0;
      end
      for (j = 4 + i; j <= n + 3; j = j + 1) begin : zero_fill_after
        assign partial_products[i][j] = 1'b0;
      end
    end
  endgenerate

  assign sums[0] = partial_products[0];

  // Sum the partial products using cascaded 4-bit adders
  generate
    for (i = 1; i <= n; i = i + 1) begin : sum_partial_products
      four_bit_adder_array #(n+4) adder (
          .a(sums[i-1]),
          .b(partial_products[i]),
          .sum(sums[i])
      );
    end
  endgenerate

  assign res = sums[n];

endmodule

module four_bit_adder_array #(parameter n = 4) (
  input [n-1:0] a,
  input [n-1:0] b,
  output [n-1:0] sum
);
  wire [((n + 3) / 4):0] carry; // One extra bit for carry out of the MSB adder
  assign carry[0] = 1'b0;

  genvar i;
  generate
    for (i = 0; i < n; i = i + 4) begin : adders
      four_bit_adder adder (
          .a(a[i + 3 -: 4]),
          .b(b[i + 3 -: 4]),
          .cin(carry[i / 4]),
          .sum(sum[i + 3 -: 4]),
          .cout(carry[(i / 4) + 1])
      );
    end
  endgenerate
  
  
  assign cout = carry[((n + 3) / 4)];
endmodule

module four_bit_adder (
    input [3:0] a,
    input [3:0] b,
    input cin,
    output [3:0] sum,
    output cout
);
  wire [3:0] c;

  genvar i;
  generate
    for (i = 0; i < 4; i = i + 1) begin : adder_loop
      full_adder fa (
        .a(a[i]),
        .b(b[i]),
        .cin(i == 0 ? cin : c[i-1]),// if i=0 its cin, else its the wire c[i-1]
        .sum(sum[i]),
        .cout(c[i])
      );
    end
  endgenerate

  assign cout = c[3];// last c, which is cout
  
endmodule


module full_adder (
    input a,
    input b,
    input cin,
    output sum,
    output cout
);
  wire w1, w2, w3;
  
  // will start instantaniously
  xor #9ns xor1 (w1,a,b);
  and #7ns and1 (w2,a,b);
  
  //will start after xor1 finishes, after 9ns (when w1 changes)
  and #7ns and2 (w3,w1,cin);//16ns
  xor #9ns xor2 (sum,w1,cin);//18ns

  //will start after and1,and2 output, since and1 ends 7ns after the beginning.
  //it will also wait for and2 output, to begin which happens 16ns after beginning.
  or #7 or1 (cout,w2,w3);//23ns

endmodule